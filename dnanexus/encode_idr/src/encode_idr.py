#!/usr/bin/env python
# encode_idr 0.0.1
# Generated by dx-app-wizard.
#
# Parallelized execution pattern: Your app will generate multiple jobs
# to perform some computation in parallel, followed by a final
# "postprocess" stage that will perform any additional computations as
# necessary.
#
# See https://wiki.dnanexus.com/Developer-Portal for documentation and
# tutorials on how to modify this file.
#
# DNAnexus Python Bindings (dxpy) documentation:
#   http://autodoc.dnanexus.com/bindings/python/current/

import os, subprocess, logging
import dxpy

def count_lines(fname):
    wc_output = subprocess.check_output(shlex.split('wc -l %s' %(fname)))
    return int(wc_output)

def blacklist_filter(peaks_fname, output_fname, blacklist_fname):
    #TODO implement blacklist filter
    subprocess.check_call(shlex.split('cp %s %s' %(peaks_fname, output_fname)))

@dxpy.entry_point("postprocess")
def postprocess(process_outputs):
    # Change the following to process whatever input this stage
    # receives.  You may also want to copy and paste the logic to download
    # and upload files here as well if this stage receives file input
    # and/or makes file output.

    print "In postprocess with process_outputs %s" %(process_outputs)

    for output in process_outputs:
        pass

    return { "pooled": process_outputs[0] }

@dxpy.entry_point("process")
def process(input1):
    # Change the following to process whatever input this stage
    # receives.  You may also want to copy and paste the logic to download
    # and upload files here as well if this stage receives file input
    # and/or makes file output.

    print input1

    return { "output": "placeholder value" }

@dxpy.entry_point("main")
def main(experiment, reps_peaks, r1pr_peaks, r2pr_peaks, pooledpr_peaks, blacklist):

    #TODO for now just taking the peak files.  This applet should actually call IDR instead of 
    #putting that in the workflow populator script

    # Initialize the data object inputs on the platform into
    # dxpy.DXDataObject instances.

    reps_peaks_file = dxpy.DXFile(reps_peaks)
    r1pr_peaks_file = dxpy.DXFile(r1pr_peaks)
    r2pr_peaks_file = dxpy.DXFile(r2pr_peaks)
    pooledpr_peaks_file = dxpy.DXFile(pooledpr_peaks)
    blacklist_file = dxpy.DXFile(blacklist)

    # Download the file inputs to the local file system.

    dxpy.download_dxfile(reps_peaks_file.get_id(), reps_peaks_file.name)
    dxpy.download_dxfile(r1pr_peaks_file.get_id(), r1pr_peaks_file.name)
    dxpy.download_dxfile(r2pr_peaks_file.get_id(), r2pr_peaks_file.name)
    dxpy.download_dxfile(pooledpr_peaks_file.get_id(), pooledpr_peaks_file.name)
    dxpy.download_dxfile(blacklist_file.get_id(), blacklist_file.name)

    Nt = count_lines(reps_peaks_file.name)
    N1 = count_lines(r1pr_peaks_file.name)
    N2 = count_lines(r2pr_peaks_file.name)
    Np = count_lines(pooledpr_peaks_file.name)

    conservative_set_filename = '%s_final_conservative.narrowPeak' %(experiment)
    blacklist_filter(reps_peaks_file.name, conservative_set_filename, blacklist_file.name)

    if Nt >= Np:
        peaks_to_filter_file = reps_peaks_file
    else:
        peaks_to_filter_file = pooledpr_peaks_file

    optimal_set_filename = '%s_optimal.narrowPeak' %(experiment)
    blacklist_filter(peaks_to_filter_file.name, optimal_set_filename, blacklist_file.nane)

    rescue_ratio            = float(max(Np,Nt)) / float(min(Np,Nt))
    self_consistency_ratio  = float(max(N1,N2)) / float(min(N1,N2))

    if rescue_ratio > 2 and self_consistency_ratio > 2:
        reproducibility = 'fail'
    elif rescue_ratio > 2 or self_consistency_ratio > 2:
        reproducibility = 'borderline'
    else:
        reproducibility = 'pass'

    #Upload the output files
    conservative_set_output = dxpy.upload_local_file(conservative_set_filename)
    optimal_set_output = dxpy.upload_local_file(optimal_set_filename)

    output = {
        "Nt": Nt,
        "N1": N1,
        "N2": N2,
        "Np": Np,
        "conservative_set": dxpy.dxlink(conservative_set_output),
        "optimal_set": dxpy.dxlink(optimal_set_output),
        "rescue_ratio": rescue_ratio,
        "self_consistency_ratio": self_consistency_ratio,
        "reproducibility_test": reproducibility
    }

    logging.info("Exiting with output: %s", output)
    return output

dxpy.run()
